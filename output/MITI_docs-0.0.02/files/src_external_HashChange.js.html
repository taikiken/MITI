<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/external/HashChange.js - MITI</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="MITI"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.02</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Annai.html">Annai</a></li>
            
                <li><a href="../classes/MITI.html">MITI</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/inazumatv.html">inazumatv</a></li>
            
                <li><a href="../modules/MITI.html">MITI</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/external/HashChange.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * license inazumatv.com
 * author (at)taikiken / htp://inazumatv.com
 * date 2013/12/18 - 11:11
 *
 * Copyright (c) 2011-2013 inazumatv.com, inc.
 *
 * Distributed under the terms of the MIT license.
 * http://www.opensource.org/licenses/mit-license.html
 *
 * This notice shall be included in all copies or substantial portions of the Software.
 */
/**
 * jQuery hashchange event - v1.3 - 7/21/2010
 * http://benalman.com/projects/jquery-hashchange-plugin/
 *
 * Copyright (c) 2010 &quot;Cowboy&quot; Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */
( function ( inazumatv ){
    &quot;use strict&quot;;
    var document = window.document,
        Browser = inazumatv.Browser
    ;

    function HashChange () {
        throw &quot;HashChange cannot be instantiated&quot;;
    }

    HashChange.activate = function ( jQuery ){
        var $ = jQuery;

        &#x27;$:nomunge&#x27;; // Used by YUI compressor.

        // Reused string.
        var str_hashchange = &#x27;hashchange&#x27;,

        // Method / object references.
            doc = document,
            fake_onhashchange,
            special = $.event.special,

        // Does the browser support window.onhashchange? Note that IE8 running in
        // IE7 compatibility mode reports true for &#x27;onhashchange&#x27; in window, even
        // though the event isn&#x27;t supported, so also test document.documentMode.
            doc_mode = doc.documentMode,
            supports_onhashchange = &#x27;on&#x27; + str_hashchange in window &amp;&amp; ( doc_mode === undefined || doc_mode &gt; 7 );


        // Get location.hash (or what you&#x27;d expect location.hash to be) sans any
        // leading #. Thanks for making this necessary, Firefox!
        function get_fragment( url ) {
            url = url || location.href;
            return &#x27;#&#x27; + url.replace( /^[^#]*#?(.*)$/, &#x27;$1&#x27; );
        }

        // Method: jQuery.fn.hashchange
        //
        // Bind a handler to the window.onhashchange event or trigger all bound
        // window.onhashchange event handlers. This behavior is consistent with
        // jQuery&#x27;s built-in event handlers.
        //
        // Usage:
        //
        // &gt; jQuery(window).hashchange( [ handler ] );
        //
        // Arguments:
        //
        //  handler - (Function) Optional handler to be bound to the hashchange
        //    event. This is a &quot;shortcut&quot; for the more verbose form:
        //    jQuery(window).bind( &#x27;hashchange&#x27;, handler ). If handler is omitted,
        //    all bound window.onhashchange event handlers will be triggered. This
        //    is a shortcut for the more verbose
        //    jQuery(window).trigger( &#x27;hashchange&#x27; ). These forms are described in
        //    the &lt;hashchange event&gt; section.
        //
        // Returns:
        //
        //  (jQuery) The initial jQuery collection of elements.

        // Allow the &quot;shortcut&quot; format $(elem).hashchange( fn ) for binding and
        // $(elem).hashchange() for triggering, like jQuery does for built-in events.
        $.fn[ str_hashchange ] = function( fn ) {
            return fn ? this.bind( str_hashchange, fn ) : this.trigger( str_hashchange );
        };

        // Property: jQuery.fn.hashchange.delay
        //
        // The numeric interval (in milliseconds) at which the &lt;hashchange event&gt;
        // polling loop executes. Defaults to 50.

        // Property: jQuery.fn.hashchange.domain
        //
        // If you&#x27;re setting document.domain in your JavaScript, and you want hash
        // history to work in IE6/7, not only must this property be set, but you must
        // also set document.domain BEFORE jQuery is loaded into the page. This
        // property is only applicable if you are supporting IE6/7 (or IE8 operating
        // in &quot;IE7 compatibility&quot; mode).
        //
        // In addition, the &lt;jQuery.fn.hashchange.src&gt; property must be set to the
        // path of the included &quot;document-domain.html&quot; file, which can be renamed or
        // modified if necessary (note that the document.domain specified must be the
        // same in both your main JavaScript as well as in this file).
        //
        // Usage:
        //
        // jQuery.fn.hashchange.domain = document.domain;

        // Property: jQuery.fn.hashchange.src
        //
        // If, for some reason, you need to specify an Iframe src file (for example,
        // when setting document.domain as in &lt;jQuery.fn.hashchange.domain&gt;), you can
        // do so using this property. Note that when using this property, history
        // won&#x27;t be recorded in IE6/7 until the Iframe src file loads. This property
        // is only applicable if you are supporting IE6/7 (or IE8 operating in &quot;IE7
        // compatibility&quot; mode).
        //
        // Usage:
        //
        // jQuery.fn.hashchange.src = &#x27;path/to/file.html&#x27;;

        $.fn[ str_hashchange ].delay = 50;
        /*
         $.fn[ str_hashchange ].domain = null;
         $.fn[ str_hashchange ].src = null;
         */

        // Event: hashchange event
        //
        // Fired when location.hash changes. In browsers that support it, the native
        // HTML5 window.onhashchange event is used, otherwise a polling loop is
        // initialized, running every &lt;jQuery.fn.hashchange.delay&gt; milliseconds to
        // see if the hash has changed. In IE6/7 (and IE8 operating in &quot;IE7
        // compatibility&quot; mode), a hidden Iframe is created to allow the back button
        // and hash-based history to work.
        //
        // Usage as described in &lt;jQuery.fn.hashchange&gt;:
        //
        // &gt; // Bind an event handler.
        // &gt; jQuery(window).hashchange( function(e) {
        // &gt;   var hash = location.hash;
        // &gt;   ...
        // &gt; });
        // &gt;
        // &gt; // Manually trigger the event handler.
        // &gt; jQuery(window).hashchange();
        //
        // A more verbose usage that allows for event namespacing:
        //
        // &gt; // Bind an event handler.
        // &gt; jQuery(window).bind( &#x27;hashchange&#x27;, function(e) {
        // &gt;   var hash = location.hash;
        // &gt;   ...
        // &gt; });
        // &gt;
        // &gt; // Manually trigger the event handler.
        // &gt; jQuery(window).trigger( &#x27;hashchange&#x27; );
        //
        // Additional Notes:
        //
        // * The polling loop and Iframe are not created until at least one handler
        //   is actually bound to the &#x27;hashchange&#x27; event.
        // * If you need the bound handler(s) to execute immediately, in cases where
        //   a location.hash exists on page load, via bookmark or page refresh for
        //   example, use jQuery(window).hashchange() or the more verbose
        //   jQuery(window).trigger( &#x27;hashchange&#x27; ).
        // * The event can be bound before DOM ready, but since it won&#x27;t be usable
        //   before then in IE6/7 (due to the necessary Iframe), recommended usage is
        //   to bind it inside a DOM ready handler.

        // Override existing $.event.special.hashchange methods (allowing this plugin
        // to be defined after jQuery BBQ in BBQ&#x27;s source code).
        special[ str_hashchange ] = $.extend( special[ str_hashchange ], {

            // Called only when the first &#x27;hashchange&#x27; event is bound to window.
            setup: function() {
                // If window.onhashchange is supported natively, there&#x27;s nothing to do..
                if ( supports_onhashchange ) { return false; }

                // Otherwise, we need to create our own. And we don&#x27;t want to call this
                // until the user binds to the event, just in case they never do, since it
                // will create a polling loop and possibly even a hidden Iframe.
                $( fake_onhashchange.start );
            },

            // Called only when the last &#x27;hashchange&#x27; event is unbound from window.
            teardown: function() {
                // If window.onhashchange is supported natively, there&#x27;s nothing to do..
                if ( supports_onhashchange ) { return false; }

                // Otherwise, we need to stop ours (if possible).
                $( fake_onhashchange.stop );
            }

        });

        // fake_onhashchange does all the work of triggering the window.onhashchange
        // event for browsers that don&#x27;t natively support it, including creating a
        // polling loop to watch for hash changes and in IE 6/7 creating a hidden
        // Iframe to enable back and forward.
        fake_onhashchange = (function(){
            var self = {},
                timeout_id,

            // Remember the initial hash so it doesn&#x27;t get triggered immediately.
                last_hash = get_fragment(),

                fn_retval = function(val){ return val; },
                history_set = fn_retval,
                history_get = fn_retval;

            // Start the polling loop.
            self.start = function() {
                timeout_id || poll();
            };

            // Stop the polling loop.
            self.stop = function() {
                timeout_id &amp;&amp; clearTimeout( timeout_id );
                timeout_id = undefined;
            };

            // This polling loop checks every $.fn.hashchange.delay milliseconds to see
            // if location.hash has changed, and triggers the &#x27;hashchange&#x27; event on
            // window when necessary.
            function poll() {
                var hash = get_fragment(),
                    history_hash = history_get( last_hash );

                // ----------------------
                // history back 時に # で汚染する対策
                if ( hash === &quot;#&quot; ) {
                    hash = &quot;&quot;;
                }
                if ( history_hash === &quot;#&quot; ) {
                    history_hash = &quot;&quot;;
                }
                // ----------------------

                if ( hash &amp;&amp; hash !== last_hash ) {
                    history_set( last_hash = hash, history_hash );

                    $(window).trigger( str_hashchange );

                } else if ( history_hash !== last_hash ) {
                    location.href = location.href.replace( /#.*/, &#x27;&#x27; ) + history_hash;
                }

                timeout_id = setTimeout( poll, $.fn[ str_hashchange ].delay );
            }//poll

            // vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
            // vvvvvvvvvvvvvvvvvvv REMOVE IF NOT SUPPORTING IE6/7/8 vvvvvvvvvvvvvvvvvvv
            // vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//            $.browser.msie &amp;&amp; !supports_onhashchange &amp;&amp; (function(){
            Browser.IE.legacy() &amp;&amp; !supports_onhashchange &amp;&amp; (function(){
                // Not only do IE6/7 need the &quot;magical&quot; Iframe treatment, but so does IE8
                // when running in &quot;IE7 compatibility&quot; mode.

                var iframe,
                    iframe_src;

                // When the event is bound and polling starts in IE 6/7, create a hidden
                // Iframe for history handling.
                self.start = function(){
                    if ( !iframe ) {
                        iframe_src = $.fn[ str_hashchange ].src;
                        iframe_src = iframe_src &amp;&amp; iframe_src + get_fragment();

                        // Create hidden Iframe. Attempt to make Iframe as hidden as possible
                        // by using techniques from http://www.paciellogroup.com/blog/?p=604.
                        iframe = $(&#x27;&lt;iframe tabindex=&quot;-1&quot; title=&quot;empty&quot;/&gt;&#x27;).hide()

                            // When Iframe has completely loaded, initialize the history and
                            // start polling.
                            .one( &#x27;load&#x27;, function(){
                                iframe_src || history_set( get_fragment() );
                                poll();
                            })

                            // Load Iframe src if specified, otherwise nothing.
                            .attr( &#x27;src&#x27;, iframe_src || &#x27;javascript:0&#x27; )

                            // Append Iframe after the end of the body to prevent unnecessary
                            // initial page scrolling (yes, this works).
                            .insertAfter( &#x27;body&#x27; )[0].contentWindow;

                        // Whenever &#x60;document.title&#x60; changes, update the Iframe&#x27;s title to
                        // prettify the back/next history menu entries. Since IE sometimes
                        // errors with &quot;Unspecified error&quot; the very first time this is set
                        // (yes, very useful) wrap this with a try/catch block.
                        doc.onpropertychange = function(){
                            try {
                                if ( event.propertyName === &#x27;title&#x27; ) {
                                    iframe.document.title = doc.title;
                                }
                            } catch(e) {}
                        };

                    }
                };

                // Override the &quot;stop&quot; method since an IE6/7 Iframe was created. Even
                // if there are no longer any bound event handlers, the polling loop
                // is still necessary for back/next to work at all!
                self.stop = fn_retval;

                // Get history by looking at the hidden Iframe&#x27;s location.hash.
                history_get = function() {
                    return get_fragment( iframe.location.href );
                };

                // Set a new history item by opening and then closing the Iframe
                // document, *then* setting its location.hash. If document.domain has
                // been set, update that as well.
                history_set = function( hash, history_hash ) {
                    // ----------------------
                    // history back 時に # で汚染する対策
                    if ( hash === &quot;#&quot; &amp;&amp; typeof history_hash === &quot;undefined&quot; ) {
                        hash = &quot;&quot;;
                    }
                    // ----------------------
                    var iframe_doc = iframe.document,
                        domain = $.fn[ str_hashchange ].domain;

                    if ( hash !== history_hash ) {
                        // Update Iframe with any initial &#x60;document.title&#x60; that might be set.
                        iframe_doc.title = doc.title;

                        // Opening the Iframe&#x27;s document after it has been closed is what
                        // actually adds a history entry.
                        iframe_doc.open();

                        // Set document.domain for the Iframe document as well, if necessary.
                        domain &amp;&amp; iframe_doc.write( &#x27;&lt;script&gt;document.domain=&quot;&#x27; + domain + &#x27;&quot;&lt;/script&gt;&#x27; );

                        iframe_doc.close();

                        // Update the Iframe&#x27;s hash, for great justice.
                        iframe.location.hash = hash;
                    }
                };

            })();
            // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // ^^^^^^^^^^^^^^^^^^^ REMOVE IF NOT SUPPORTING IE6/7/8 ^^^^^^^^^^^^^^^^^^^
            // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

            return self;
        })();//fake_onhashchange
    };

    inazumatv.jq.HashChange = HashChange;
}( this.inazumatv ) );
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
